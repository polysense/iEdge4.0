/**
 * @file  mtlcd_fbuf.c
 * @brief MT LCD液晶面板帧缓冲显示驱动
 * @author Runby F.
 * @date 2022-4-1
 * @copyright Polysense
 */

#include "drv_api.h"
#include "drv_mtlcd.h"

/**
 * @brief 16x19点阵字库
 */
const static pos_u8_t _fonts_hz16[][HZ16_DOT_SIZE*3] = {
    {0x00,0x80,0xF0,0x70,0x40,0xF8,0xF8,0x40,0x40,0x40,0xC0,0xC0,0x00,0xF8,0xF8,0x00,0x02,0x02,0xF2,0xF2,0x12,0xFF,0xFF,0x92,0xF2,0xF2,0x7F,0x7F,0x00,0xFF,0xFF,0x00,0x00,0x00,0x01,0x01,0x00,0x07,0x07,0x01,0x01,0x00,0x00,0x02,0x06,0x07,0x03,0x00},/*"?",0*/
    /* (16 X 19 , 制 )*/
    {0x00,0x80,0x80,0x80,0x80,0xF8,0xF8,0x80,0x80,0xF8,0xF8,0x80,0x80,0x80,0x80,0x00,0x00,0xFF,0xFF,0x10,0x10,0xFF,0xFF,0x10,0x10,0xFF,0xFF,0x10,0x10,0xFF,0xFF,0x00,0x00,0x07,0x07,0x02,0x02,0x03,0x03,0x02,0x02,0x03,0x03,0x02,0x02,0x07,0x07,0x00},/*"?",1*/
    /* (16 X 19 , 曲 )*/
    {0x00,0x10,0x70,0x60,0x10,0x90,0x90,0x90,0xF0,0xF0,0xF0,0xF0,0x90,0x90,0x90,0x10,0x21,0x27,0xF6,0xFC,0x0C,0xFF,0xFF,0x58,0x4F,0x47,0x47,0x4F,0x48,0xFF,0xFF,0x00,0x00,0x00,0x03,0x03,0x00,0x07,0x07,0x02,0x02,0x02,0x02,0x02,0x02,0x07,0x07,0x00},/*"?",2*/
    /* (16 X 19 , 酒 )*/
    {0x00,0x10,0x60,0x00,0x00,0x20,0xA0,0xA0,0xA0,0xF8,0xA0,0xA0,0xA0,0x20,0x00,0x00,0x02,0x02,0xFE,0x00,0x80,0x02,0xFA,0xAA,0xAA,0xAB,0xAA,0xAA,0xFA,0x02,0x02,0x00,0x00,0x00,0x03,0x01,0x00,0x00,0x07,0x00,0x00,0x00,0x02,0x04,0x03,0x00,0x00,0x00},/*"?",0*/
    /* (16 X 19 , 请 )*/
    {0x00,0x00,0xF0,0x90,0x90,0x90,0x90,0x90,0x90,0xF0,0x00,0x80,0x00,0x00,0xF8,0x00,0x80,0x70,0x0F,0xF8,0x08,0x08,0xFF,0x88,0x08,0xF8,0x00,0x7F,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x07,0x00,0x01,0x00,0x00,0x00,0x02,0x04,0x03,0x00},/*"?",1*/
    /* (16 X 19 , 刷 )*/
    {0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0x02,0x02,0x02,0x02,0x02,0x02,0xFF,0x02,0x02,0x12,0x22,0x42,0x82,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"?",2*/
    /* (16 X 19 , 卡 )*/    
    {0x00,0x00,0xC0,0x40,0x40,0x40,0x40,0x40,0x40,0xF8,0x40,0x48,0x50,0x40,0x40,0x00,0x00,0x00,0xFF,0x04,0x84,0x04,0xFC,0x00,0x00,0x0F,0xB0,0xC0,0x30,0x0E,0xC0,0x00,0x04,0x03,0x00,0x00,0x00,0x01,0x00,0x04,0x02,0x01,0x00,0x00,0x01,0x02,0x07,0x00},/*"?",0*/
    /* (16 X 19 , 成 )*/
    {0x40,0x40,0x40,0xC0,0x40,0x40,0x40,0x80,0x80,0xF8,0x80,0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0xFF,0x40,0x40,0x40,0x80,0x70,0x0F,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x04,0x02,0x01,0x00,0x00,0x02,0x04,0x02,0x01,0x00,0x00},/*"?",1*/
    /* (16 X 19 , 功 )*/
    {0x00,0x00,0x40,0x40,0x40,0x40,0x40,0xF8,0x40,0x40,0x40,0x40,0x40,0x00,0x00,0x00,0x04,0x04,0x84,0x44,0x24,0x14,0x0C,0xFF,0x0C,0x14,0x24,0x44,0x84,0x04,0x04,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x00},/*"?",0*/
    /* (16 X 19 , 未 )*/
    {0x80,0x80,0x80,0xF8,0x80,0x80,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0xE0,0x00,0x00,0x20,0x20,0x10,0xFF,0x08,0x04,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0xFF,0x00,0x00,0x00,0x02,0x04,0x03,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x03,0x00,0x00},/*"?",1*/
    /* (16 X 19 , 扫 )*/
    {0x20,0x20,0x20,0xE0,0x20,0x20,0x00,0x10,0x90,0x10,0x10,0x10,0xF0,0x00,0x00,0x00,0x10,0x0C,0xFF,0x82,0x82,0xFE,0x00,0x40,0x47,0x44,0x44,0x44,0x47,0x04,0xFC,0x00,0x00,0x00,0x03,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x02,0x04,0x02,0x01,0x00},/*"?",2*/
    /* (16 X 19 , 码 )*/    
};

/**
 * @brief 12x14点阵字库
 */
const static pos_u8_t _fonts_hz[][HZ_DOT_SIZE*2] = {
{0x60,0x58,0x50,0xFC,0x50,0x50,0x40,0xF0,0x00,0x00,0xFC,0x00,0x00,0x1F,0x01,0x3F,0x11,0x1F,0x00,0x07,0x20,0x20,0x3F,0x00},
/* (12 X 14 , 制 )*/

{0x00,0xF0,0x10,0x10,0xFC,0x10,0x10,0xFC,0x10,0x10,0xF0,0x00,0x00,0x3F,0x11,0x11,0x1F,0x11,0x11,0x1F,0x11,0x11,0x3F,0x00},
/* (12 X 14 , 曲 )*/

{0x10,0x90,0x50,0x30,0x1C,0xD0,0x10,0x10,0x10,0x10,0x10,0x00,0x08,0x09,0x09,0x09,0x09,0x3F,0x09,0x09,0x09,0x09,0x08,0x00},
/* (12 X 14 , 车 )*/

{0x00,0xE4,0x08,0xE0,0x24,0x24,0x24,0x24,0xE4,0x04,0xFC,0x00,0x00,0x3F,0x00,0x0F,0x09,0x09,0x09,0x09,0x2F,0x20,0x3F,0x00},
/* (12 X 14 , 间 )*/

{0x88,0xF8,0x88,0xE0,0x00,0xFC,0x00,0x08,0xF8,0x08,0x08,0x00,0x10,0x1F,0x0A,0x21,0x18,0x07,0x20,0x21,0x3F,0x21,0x21,0x00},
/* (12 X 14 , 班 )*/

{0x60,0x50,0xCC,0x20,0x00,0xF8,0x48,0x48,0x48,0xF8,0x00,0x00,0x12,0x13,0x0A,0x0A,0x20,0x3F,0x22,0x22,0x22,0x3F,0x20,0x00},
/* (12 X 14 , 组 )*/

{0x18,0x28,0xD8,0x88,0x88,0xEC,0x88,0x88,0x98,0xA8,0x18,0x00,0x02,0x3B,0x2A,0x2A,0x2A,0x2B,0x2A,0x2A,0x2A,0x3A,0x02,0x00},
/* (12 X 14 , 酵 )*/

{0x88,0x10,0x00,0xF0,0x80,0x40,0xFC,0x20,0x10,0xF0,0x00,0x00,0x10,0x09,0x01,0x1F,0x20,0x20,0x2F,0x20,0x24,0x27,0x30,0x00},
/* (12 X 14 , 堆 )*/

{0xE8,0x28,0xF8,0x28,0xE8,0xA0,0xA8,0xFC,0xA8,0xB0,0x28,0x00,0x3F,0x15,0x14,0x15,0x3F,0x02,0x05,0x24,0x3E,0x05,0x04,0x00},
/* (12 X 14 , 窖 )*/

{0x20,0x20,0xFC,0xA0,0x40,0xF0,0x9C,0x90,0xF4,0x98,0x90,0x00,0x10,0x10,0x0F,0x08,0x00,0x3F,0x24,0x24,0x3F,0x24,0x24,0x00},
/* (12 X 14 , 池 )*/

{0x90,0xA0,0xFC,0xA0,0x90,0xF0,0x54,0x58,0x50,0xF0,0x00,0x00,0x04,0x02,0x3F,0x02,0x04,0x3F,0x11,0x07,0x09,0x15,0x22,0x00},
/* (12 X 14 , 粮 )*/

{0x88,0x10,0x08,0xE8,0x28,0xF8,0x28,0xF8,0x28,0xE8,0x08,0x00,0x10,0x09,0x00,0x3F,0x15,0x14,0x14,0x14,0x15,0x3F,0x00,0x00},
/* (12 X 14 , 酒 )*/
};

/**
 * @brief 8x8 ASCII点阵字库
 */
const static pos_u8_t _fonts[][5] = {
  {0x00, 0x00, 0x00, 0x00, 0x00 }, // sp
  {0x00,0x00,0x4F,0x00,0x00},   //   (  1)  ! - 0x0021 Exclamation Mark
  {0x00,0x07,0x00,0x07,0x00},   //   (  2)  " - 0x0022 Quotation Mark
  {0x14,0x7F,0x14,0x7F,0x14},   //   (  3)  # - 0x0023 Number Sign
  {0x24,0x2A,0x7F,0x2A,0x12},   //   (  4)  $ - 0x0024 Dollar Sign
  {0x23,0x13,0x08,0x64,0x62},   //   (  5)  % - 0x0025 Percent Sign
  {0x36,0x49,0x55,0x22,0x50},   //   (  6)  & - 0x0026 Ampersand
  {0x00,0x05,0x03,0x00,0x00},   //   (  7)  ' - 0x0027 Apostrophe
  {0x00,0x1C,0x22,0x41,0x00},   //   (  8)  ( - 0x0028 Left Parenthesis
  {0x00,0x41,0x22,0x1C,0x00},   //   (  9)  ) - 0x0029 Right Parenthesis
  {0x14,0x08,0x3E,0x08,0x14},   //   ( 10)  * - 0x002A Asterisk
  {0x08,0x08,0x3E,0x08,0x08},   //   ( 11)  + - 0x002B Plus Sign
  {0x00,0x50,0x30,0x00,0x00},   //   ( 12)  , - 0x002C Comma
  {0x08,0x08,0x08,0x08,0x08},   //   ( 13)  - - 0x002D Hyphen-Minus
  {0x00,0x60,0x60,0x00,0x00},   //   ( 14)  . - 0x002E Full Stop
  {0x20,0x10,0x08,0x04,0x02},   //   ( 15)  / - 0x002F Solidus
  {0x3E,0x51,0x49,0x45,0x3E},   //   ( 16)  0 - 0x0030 Digit Zero
  {0x00,0x42,0x7F,0x40,0x00},   //   ( 17)  1 - 0x0031 Digit One
  {0x42,0x61,0x51,0x49,0x46},   //   ( 18)  2 - 0x0032 Digit Two
  {0x21,0x41,0x45,0x4B,0x31},   //   ( 19)  3 - 0x0033 Digit Three
  {0x18,0x14,0x12,0x7F,0x10},   //   ( 20)  4 - 0x0034 Digit Four
  {0x27,0x45,0x45,0x45,0x39},   //   ( 21)  5 - 0x0035 Digit Five
  {0x3C,0x4A,0x49,0x49,0x30},   //   ( 22)  6 - 0x0036 Digit Six
  {0x01,0x71,0x09,0x05,0x03},   //   ( 23)  7 - 0x0037 Digit Seven
  {0x36,0x49,0x49,0x49,0x36},   //   ( 24)  8 - 0x0038 Digit Eight
  {0x06,0x49,0x49,0x29,0x1E},   //   ( 25)  9 - 0x0039 Dight Nine
  {0x00,0x36,0x36,0x00,0x00},   //   ( 26)  : - 0x003A Colon
  {0x00,0x56,0x36,0x00,0x00},   //   ( 27)  ; - 0x003B Semicolon
  {0x08,0x14,0x22,0x41,0x00},   //   ( 28)  < - 0x003C Less-Than Sign
  {0x14,0x14,0x14,0x14,0x14},   //   ( 29)  = - 0x003D Equals Sign
  {0x00,0x41,0x22,0x14,0x08},   //   ( 30)  > - 0x003E Greater-Than Sign
  {0x02,0x01,0x51,0x09,0x06},   //   ( 31)  ? - 0x003F Question Mark
  {0x32,0x49,0x79,0x41,0x3E},   //   ( 32)  @ - 0x0040 Commercial At
  {0x7E,0x11,0x11,0x11,0x7E},   //   ( 33)  A - 0x0041 Latin Capital Letter A
  {0x7F,0x49,0x49,0x49,0x36},   //   ( 34)  B - 0x0042 Latin Capital Letter B
  {0x3E,0x41,0x41,0x41,0x22},   //   ( 35)  C - 0x0043 Latin Capital Letter C
  {0x7F,0x41,0x41,0x22,0x1C},   //   ( 36)  D - 0x0044 Latin Capital Letter D
  {0x7F,0x49,0x49,0x49,0x41},   //   ( 37)  E - 0x0045 Latin Capital Letter E
  {0x7F,0x09,0x09,0x09,0x01},   //   ( 38)  F - 0x0046 Latin Capital Letter F
  {0x3E,0x41,0x49,0x49,0x7A},   //   ( 39)  G - 0x0047 Latin Capital Letter G
  {0x7F,0x08,0x08,0x08,0x7F},   //   ( 40)  H - 0x0048 Latin Capital Letter H
  {0x00,0x41,0x7F,0x41,0x00},   //   ( 41)  I - 0x0049 Latin Capital Letter I
  {0x20,0x40,0x41,0x3F,0x01},   //   ( 42)  J - 0x004A Latin Capital Letter J
  {0x7F,0x08,0x14,0x22,0x41},   //   ( 43)  K - 0x004B Latin Capital Letter K
  {0x7F,0x40,0x40,0x40,0x40},   //   ( 44)  L - 0x004C Latin Capital Letter L
  {0x7F,0x02,0x0C,0x02,0x7F},   //   ( 45)  M - 0x004D Latin Capital Letter M
  {0x7F,0x04,0x08,0x10,0x7F},   //   ( 46)  N - 0x004E Latin Capital Letter N
  {0x3E,0x41,0x41,0x41,0x3E},   //   ( 47)  O - 0x004F Latin Capital Letter O
  {0x7F,0x09,0x09,0x09,0x06},   //   ( 48)  P - 0x0050 Latin Capital Letter P
  {0x3E,0x41,0x51,0x21,0x5E},   //   ( 49)  Q - 0x0051 Latin Capital Letter Q
  {0x7F,0x09,0x19,0x29,0x46},   //   ( 50)  R - 0x0052 Latin Capital Letter R
  {0x46,0x49,0x49,0x49,0x31},   //   ( 51)  S - 0x0053 Latin Capital Letter S
  {0x01,0x01,0x7F,0x01,0x01},   //   ( 52)  T - 0x0054 Latin Capital Letter T
  {0x3F,0x40,0x40,0x40,0x3F},   //   ( 53)  U - 0x0055 Latin Capital Letter U
  {0x1F,0x20,0x40,0x20,0x1F},   //   ( 54)  V - 0x0056 Latin Capital Letter V
  {0x3F,0x40,0x38,0x40,0x3F},   //   ( 55)  W - 0x0057 Latin Capital Letter W
  {0x63,0x14,0x08,0x14,0x63},   //   ( 56)  X - 0x0058 Latin Capital Letter X
  {0x07,0x08,0x70,0x08,0x07},   //   ( 57)  Y - 0x0059 Latin Capital Letter Y
  {0x61,0x51,0x49,0x45,0x43},   //   ( 58)  Z - 0x005A Latin Capital Letter Z
  {0x00,0x7F,0x41,0x41,0x00},   //   ( 59)  [ - 0x005B Left Square Bracket
  {0x02,0x04,0x08,0x10,0x20},   //   ( 60)  \ - 0x005C Reverse Solidus
  {0x00,0x41,0x41,0x7F,0x00},   //   ( 61)  ] - 0x005D Right Square Bracket
  {0x04,0x02,0x01,0x02,0x04},   //   ( 62)  ^ - 0x005E Circumflex Accent
  {0x40,0x40,0x40,0x40,0x40},   //   ( 63)  _ - 0x005F Low Line
  {0x01,0x02,0x04,0x00,0x00},   //   ( 64)  ` - 0x0060 Grave Accent
  {0x20,0x54,0x54,0x54,0x78},   //   ( 65)  a - 0x0061 Latin Small Letter A
  {0x7F,0x48,0x44,0x44,0x38},   //   ( 66)  b - 0x0062 Latin Small Letter B
  {0x38,0x44,0x44,0x44,0x20},   //   ( 67)  c - 0x0063 Latin Small Letter C
  {0x38,0x44,0x44,0x48,0x7F},   //   ( 68)  d - 0x0064 Latin Small Letter D
  {0x38,0x54,0x54,0x54,0x18},   //   ( 69)  e - 0x0065 Latin Small Letter E
  {0x08,0x7E,0x09,0x01,0x02},   //   ( 70)  f - 0x0066 Latin Small Letter F
  {0x06,0x49,0x49,0x49,0x3F},   //   ( 71)  g - 0x0067 Latin Small Letter G
  {0x7F,0x08,0x04,0x04,0x78},   //   ( 72)  h - 0x0068 Latin Small Letter H
  {0x00,0x44,0x7D,0x40,0x00},   //   ( 73)  i - 0x0069 Latin Small Letter I
  {0x20,0x40,0x44,0x3D,0x00},   //   ( 74)  j - 0x006A Latin Small Letter J
  {0x7F,0x10,0x28,0x44,0x00},   //   ( 75)  k - 0x006B Latin Small Letter K
  {0x00,0x41,0x7F,0x40,0x00},   //   ( 76)  l - 0x006C Latin Small Letter L
  {0x7C,0x04,0x18,0x04,0x7C},   //   ( 77)  m - 0x006D Latin Small Letter M
  {0x7C,0x08,0x04,0x04,0x78},   //   ( 78)  n - 0x006E Latin Small Letter N
  {0x38,0x44,0x44,0x44,0x38},   //   ( 79)  o - 0x006F Latin Small Letter O
  {0x7C,0x14,0x14,0x14,0x08},   //   ( 80)  p - 0x0070 Latin Small Letter P
  {0x08,0x14,0x14,0x18,0x7C},   //   ( 81)  q - 0x0071 Latin Small Letter Q
  {0x7C,0x08,0x04,0x04,0x08},   //   ( 82)  r - 0x0072 Latin Small Letter R
  {0x48,0x54,0x54,0x54,0x20},   //   ( 83)  s - 0x0073 Latin Small Letter S
  {0x04,0x3F,0x44,0x40,0x20},   //   ( 84)  t - 0x0074 Latin Small Letter T
  {0x3C,0x40,0x40,0x20,0x7C},   //   ( 85)  u - 0x0075 Latin Small Letter U
  {0x1C,0x20,0x40,0x20,0x1C},   //   ( 86)  v - 0x0076 Latin Small Letter V
  {0x3C,0x40,0x30,0x40,0x3C},   //   ( 87)  w - 0x0077 Latin Small Letter W
  {0x44,0x28,0x10,0x28,0x44},   //   ( 88)  x - 0x0078 Latin Small Letter X
  {0x0C,0x50,0x50,0x50,0x3C},   //   ( 89)  y - 0x0079 Latin Small Letter Y
  {0x44,0x64,0x54,0x4C,0x44},   //   ( 90)  z - 0x007A Latin Small Letter Z
  {0x00,0x08,0x36,0x41,0x00},   //   ( 91)  { - 0x007B Left Curly Bracket
  {0x00,0x00,0x7F,0x00,0x00},   //   ( 92)  | - 0x007C Vertical Line
  {0x00,0x41,0x36,0x08,0x00},   //   ( 93)  } - 0x007D Right Curly Bracket
  {0x02,0x01,0x02,0x04,0x02},   //   ( 94)  ~ - 0x007E Tilde
  {0x3E,0x55,0x55,0x41,0x22},   //   ( 95)  C - 0x0080 <Control>
};

/**
 * @brief 把帧缓存输出到LCD显示 
 */
void mtlcd_fbuf_screen_output(mtlcd_param_t *p, pos_u8_t *buf1k ) {
  pos_u32_t page;
  for( page = 0; page < MB_LCD_HEIGHT/8; page++ ) {
    mtlcd_drv_set_page_column(p, page, 0);
    mtlcd_drv_write_stream(p, &buf1k[page*MB_LCD_WIDTH], MB_LCD_WIDTH, 1);
  }  
}

/**
 * @brief 清除帧缓存并重置首字符位置
 */
void mtlcd_fbuf_clrscr(mtlcd_param_t *p) {
  /* init all zero by default */
  p->drv.os->memset(p->fbuf, 0, LCD_FBUF_SIZE);
  p->ch_x = 0;
  p->ch_y = 0;
}

/**
 * @brief 指定帧缓存字符XY位置
 */
void mtlcd_fbuf_goto(mtlcd_param_t *p, pos_u32_t x, pos_u32_t y) {
  p->ch_x = ( x < LCD_CH_X_MAX ? x : LCD_CH_X_MAX ); 
  p->ch_y = ( y < LCD_CH_Y_MAX ? y : LCD_CH_Y_MAX ); 
}

/**
 * @brief 指定帧缓存字符X位置
 */
void mtlcd_fbuf_gotox(mtlcd_param_t *p, pos_u32_t x) {
   p->ch_x = ( x < LCD_CH_X_MAX ? x : LCD_CH_X_MAX );
 
}

/**
 * @brief 把当前全局帧缓存输出到LCD显示 
 */
void mtlcd_fbuf_show(mtlcd_param_t *p) {
  mtlcd_fbuf_screen_output(p, p->fbuf);
}

/**
 * @brief 在指定位置打印16点阵汉字 (只支持16点阵)
 */
void mtlcd_fbuf_puthz16_xy(mtlcd_param_t *p, pos_u16_t x, pos_u16_t y, HZ_t hz) {
  pos_u16_t i, j;
//  pos_u32_t v;
  if( hz >= HZ_MAX || hz < HZ_ZHI16 )
    return;

  /* remap to hz16 id */
  hz = (HZ_t)(hz - HZ_ZHI16);

  /* out of screen protection */  
  if( x > MB_LCD_WIDTH - HZ16_DOT_SIZE  )
    return;
  if( y > MB_LCD_HEIGHT - 19  )
    return;

  i = (y/8)*MB_LCD_WIDTH+x+1;
//  y = y&7;
  for( j = 0; j < HZ16_DOT_SIZE; j++ ) {
    p->drv.os->memcpy(&p->fbuf[i], &_fonts_hz16[hz][0], HZ16_DOT_SIZE);
    p->drv.os->memcpy(&p->fbuf[i+MB_LCD_WIDTH], &_fonts_hz16[hz][HZ16_DOT_SIZE], HZ16_DOT_SIZE);  
    p->drv.os->memcpy(&p->fbuf[i+MB_LCD_WIDTH*2], &_fonts_hz16[hz][HZ16_DOT_SIZE*2], HZ16_DOT_SIZE);      
  }
}

/**
 * @brief 在指定位置打印汉字 (包括16点阵和12点阵)
 */
void mtlcd_fbuf_puthz_xy(mtlcd_param_t *p, pos_u16_t x, pos_u16_t y, HZ_t hz) {
  pos_u16_t i, j;
//  pos_u32_t v;
  if( hz >= HZ_ZHI16 ) {
    mtlcd_fbuf_puthz16_xy(p, x, y, hz);
    return;
  }
  
  /* out of screen protection */  
  if( x > MB_LCD_WIDTH - HZ_DOT_SIZE  )
    return;
  if( y > MB_LCD_HEIGHT - HZ_DOT_SIZE  )
    return;

  i = (y/8)*MB_LCD_WIDTH+x+1;
//  y = y&7;
  for( j = 0; j < HZ_DOT_SIZE; j++ ) {
    p->drv.os->memcpy(&p->fbuf[i], &_fonts_hz[hz][0], HZ_DOT_SIZE);
    p->drv.os->memcpy(&p->fbuf[i+MB_LCD_WIDTH], &_fonts_hz[hz][HZ_DOT_SIZE], HZ_DOT_SIZE);  
  }
}

/**
 * @brief 画线段(x,y)->(x_end,y), 以及线段(x,y)->(x,y_end)
 */
void mtlcd_fbuf_line(mtlcd_param_t *p, pos_u16_t x, pos_u16_t y, pos_u16_t x_end, pos_u16_t y_end) {
  pos_u16_t i;
  if( x_end > MB_LCD_WIDTH - 1 )
    x_end = MB_LCD_WIDTH - 1;
  if( y_end > MB_LCD_HEIGHT - 1 )
    y_end = MB_LCD_HEIGHT - 1;
  for( i = x; i <= x_end; i++ ) {
    p->fbuf[(y/8)*MB_LCD_WIDTH+i] |= 1 << (y&7);
  }
  for( i = y; i <= y_end; i++ ) {
    p->fbuf[(i/8)*MB_LCD_WIDTH+x] |= 1 << (i&7);
  }  
}

/**
 * @brief 画矩形
 */
void mtlcd_fbuf_rectangle(mtlcd_param_t *p, pos_u16_t x, pos_u16_t y, pos_u16_t x_end, pos_u16_t y_end) {
  mtlcd_fbuf_line(p, x, y, x_end, y_end);
  mtlcd_fbuf_line(p, x, y_end, x_end, 0);
  mtlcd_fbuf_line(p, x_end, y, 0, y_end);  
}

/**
 * @brief 画联网状态百分比信号
 */
void mtlcd_fbuf_network(mtlcd_param_t *p, pos_u16_t x, pos_u16_t y, pos_u8_t percentage) {
  pos_u16_t id, i;
  id = (y/8)*MB_LCD_WIDTH+x;
  p->fbuf[id++] = 0x60;  
  if( percentage ) {
    const pos_u8_t _pattern[] = {0x70, 0x78, 0x7c, 0x7e};    
    /*
     *
     *         *
     *       * *
     *     * * *
     *   * * * *
     * * * * * *
     * * * * * *
     */    
    for( i = 0; i < 4; i++ ) {
      if( percentage < 20 )
        break;
      percentage -= 20;
      p->fbuf[id++] = 0x00;
      p->fbuf[id++] = _pattern[i];
    }
  } else {
    const pos_u8_t _pattern_notready[] = {0x00, 0x71, 0x22, 0x14, 0x8, 0x14, 0x22, 0x41};   
    /*
     *   *     *
     *    *   *
     *     * *
     *      * 
     *   * * *
     * * **   *
     * * *     *
     */     
    p->drv.os->memcpy(&p->fbuf[id], _pattern_notready, sizeof(_pattern_notready));
  }
}

/**
 * @brief 画电池百分比电量
 */
void mtlcd_fbuf_battery(mtlcd_param_t *p, pos_u16_t x, pos_u16_t y, pos_u8_t percentage) {
  pos_u16_t id, i;
  id = (y/8)*MB_LCD_WIDTH+x;

  /* 充电符号和百分比增量动画*/
  if( p->flags & DRV_MTLCD_FLAG_DC ) {
#if 0    
    p->fbuf[id-3] = 0x14;
    p->fbuf[id-2] = 0x38;
    p->fbuf[id-1] = 0x50;    
#else
  p->fbuf[id-6] = 0x06;
  p->fbuf[id-5] = 0x0b;
  p->fbuf[id-4] = 0x7a;
  p->fbuf[id-3] = 0x0b;
  p->fbuf[id-2] = 0x06;    
#endif
    i = p[1].lcd_time;
    i += percentage;
    if( i > 100 ) {
      i = 100;
      p[1].lcd_time = 0; /* 重新计数 */
    }
    percentage = i;
  }
  
  p->fbuf[id++] = 0x7e;
  for( i = 10; i < 100; i+=10 ) {
    p->fbuf[id++] = 0x42;
    p->fbuf[id++] = percentage >= i ? 0x5a : 0x42;
  }
  p->fbuf[id++] = 0x42;	
  p->fbuf[id++] = 0x7e;
  p->fbuf[id++] = 0x24;
  p->fbuf[id++] = 0x3c;  
}

/**
 * @brief 当前位置打印ASCII字符
 */
void mtlcd_fbuf_putchar(mtlcd_param_t *p, pos_u8_t ch) {
  if( p->ch_y > LCD_CH_Y_MAX  )
    return;

  /* control characters */
  if( ch < ' ' ) {
    /* process \n */
    if( ch == '\n' ) {
      p->ch_x = 0;
      p->ch_y++;
      return;
    } 

    /* process \t */
    if( ch == '\t' && p->ch_x <= LCD_CH_X_MAX) {
      p->ch_x += 8 - (p->ch_x&7);
      return;
    }

    /* process \b */
    if( ch == '\b' && p->ch_x) {
      p->ch_x--;
      return;
    }

    /* process \b */
    if( ch == '\r' ) {
      p->ch_x = 0;
      return;
    }  

    /* process \a */
    if( ch == '\a' ) {
      /* 此处需要驱动扬声器BEEP, 暂不支持 */
      return;
    }
  }
  
  /* out of screen protection */
  if( p->ch_x > LCD_CH_X_MAX )
    return;
  
  /* translate to fonts index unkown chars will be replaced by space */
  if( ch < 32 )
    ch = 0;
  else
    ch -= 32;
  p->drv.os->memcpy(&p->fbuf[p->ch_y*MB_LCD_WIDTH+p->ch_x*6+1], _fonts[ch], 5);
  p->ch_x++;
}

/**
 * @brief 当前位置打印ASCII字符串
 */
void mtlcd_fbuf_puts(mtlcd_param_t *p, char *s) {
  if( p->ch_y > LCD_CH_Y_MAX )
    return;
  while(*s) {
    mtlcd_fbuf_putchar(p, *s++);
  }
}

/**
 * @brief 分配并初始化帧缓存
 */
pos_status_t mtlcd_fbuf_init(mtlcd_param_t *p) {
  p->fbuf = p->drv.os->malloc(LCD_FBUF_SIZE);
  if( !p->fbuf )
    return POS_STATUS_E_MEM;

  mtlcd_fbuf_clrscr(p);
  
  return POS_STATUS_OK;
}

/**
 * @brief 释放帧缓存
 */
void mtlcd_fbuf_done(mtlcd_param_t *p) {
  if( p->fbuf )
    p->drv.os->free(p->fbuf);
  p->fbuf = POS_NULL;
}

/**
 * @brief 电池电压转换为电量百分比
 * @param[in] v 电池电压毫伏
 * @return 电量百分比
 */
pos_u32_t mtlcd_vbat_to_percentage(mtlcd_param_t *p) {
  pos_u32_t v;
  v = VBAT_GET(p);
#define v_max 8400
#define v_min 6000
  if( v >= v_max )
    return 100;
  if( v <= v_min )
    return 0;
#if 1
  v = (v - v_min) * 100 / (v_max - v_min);

#else
  v = p->drv.os->util->umd(v - v_min, 100, v_max - v_min);
#endif

  return v;
}

/**
 * @brief RFID中提取信息
 * @param[in] rfid RFID数值
 * @param[in] item 提取数值(0:车间, 1:班组, 2:操作台位置, 3:车间类型, 4:传感器类型)
 * @return 电量百分比
 */
pos_u32_t mtlcd_rfid_to_workshop(pos_u32_t rfid, pos_u32_t item) {
  pos_u32_t mod, div;
#if 0  
  const pos_lib_util_t *util = p->drv.os->util;
#endif
  switch(item) {
  case 0: /* 车间 */
    mod = 1000000000;
    div = 10000000;
    break;
    
  case 1: /* 班组 */
    mod = 10000000;
    div = 100000;
    break;
    
  case 2: /* 操作台位置 */
    mod = 1000;
    div = 1;
    break;  
    
  case 3: /* 车间类型 */
    return rfid / 1000000000;
    break;        
    
  default: /* 传感器类型 */
    mod = 100000;
    div = 1000;
    break;
  }

#if 1
  return ( rfid % mod ) / div;
  
#else
  rfid = util->umod(rfid, mod); /* rfid = rfid % mod */
  return util->umd(rfid, 1, div); /* rfid = rfid / div */
#endif  
}

/**
 * @brief LCD屏幕驱动以及字符打印
 * @param[in] p 参数控制块
 * @param[in] disp_mode 显示模式(0:温度(或者未扫码提示), 1:成功, 2:请刷卡, 3:系统初始化)
 */
void mtlcd_refresh(mtlcd_param_t *p, pos_u8_t disp_mode) {
  pos_u8_t i;
  pos_u32_t v, rfid;
  pos_i16_t t;  
  char buf[32];
  const pos_lib_t *os;
  const pos_lib_util_t *util = p->drv.os->util;
  os = p->drv.os;
  
  /* 分配并初始化帧缓存 */
  if( mtlcd_fbuf_init(p) != POS_STATUS_OK ) {
    /* 内存出错直接退出 */
    p->drv.log->data("mtlcd fbuf err",0);
    return;
  }
  
  /* 显示RFID数字 */  
  rfid = RFID_GET_U32(p);
  os->sprintf(buf, "[0%u]\n", rfid );
  mtlcd_fbuf_puts(p,buf);
  
  /* 显示最近一次联网状态及信号强度(非实时) */  
#if 0  
  mtlcd_fbuf_network(p, 96, 0, (p->drv.ext->flag & MA_EXT_FLAG_MODULE_READY) == 0 ? 0 : 100);
#endif

  /* 显示电量百分比 */
  mtlcd_fbuf_battery(p, 104, 0, mtlcd_vbat_to_percentage(p));

  /* 显示车间班组位置信息 */
  os->sprintf(buf, "\n\n      %4u %4u %4u\n", 
    mtlcd_rfid_to_workshop(rfid, 0),
    mtlcd_rfid_to_workshop(rfid, 1),
    mtlcd_rfid_to_workshop(rfid, 2) 
  );
  mtlcd_fbuf_puts(p,buf);

  /* RFID详细解析 */
  if( rfid ) {
    HZ_t hz1, hz2;  
    mtlcd_fbuf_puthz_xy(p, 0, 8, HZ_ZHI16);
    mtlcd_fbuf_puthz_xy(p, 16, 8, 
      mtlcd_rfid_to_workshop(rfid, 3) == 1 ? HZ_JIU16 : HZ_QU16);
    mtlcd_fbuf_puthz_xy(p, 36, 8, HZ_CHE);
    mtlcd_fbuf_puthz_xy(p, 48, 8, HZ_JIAN);
    mtlcd_fbuf_puthz_xy(p, 68, 8, HZ_BAN);
    mtlcd_fbuf_puthz_xy(p, 80, 8, HZ_ZU);
    i = mtlcd_rfid_to_workshop(rfid, 4);
    switch( i ) {
    case 1:
      hz1 = HZ_LIANG;
      hz2 = HZ_DUI;
      break;
    case 2:
      hz1 = HZ_XIAO;
      hz2 = HZ_DUI;  
      break;
    default:
      hz1 = HZ_JIAO;
      hz2 = HZ_CHI;  
      break;
    }
    mtlcd_fbuf_puthz_xy(p, 100, 8, hz1);
    mtlcd_fbuf_puthz_xy(p, 112, 8, hz2); 
  }

  /* 显示不同模式内容 */
  switch( disp_mode ) {
  case 0: 
    /* RFID为空显示未扫码提示并告警 */
    if( rfid == 0 ) {
      mtlcd_fbuf_puthz_xy(p, 40, 24+8, HZ_WEI16);
      mtlcd_fbuf_puthz_xy(p, 56, 24+8, HZ_SAO16);
      mtlcd_fbuf_puthz_xy(p, 72, 24+8, HZ_MA16);      

      /* 无效RFID告警 */
      if( (p->flags & DRV_MTLCD_FLAG_NO_ALARM) == 0 ) {
        mtlcd_alarm_set(p, 1);  
        p->flags |= DRV_MTLCD_FLAG_NO_ALARM; /* one round of alarm */
      }
      break;
    }      
    
    /* 温度 */    
    v = p->drv.history->temp_num;
    for( i = 0; i < v; i++ ) {      
      os->sprintf(buf, "T%u:", i+1); /* 1 based */
      mtlcd_fbuf_puts(p, buf);
      t = p->drv.history->temp[i];
      if( t < -2000 || t > 4500 )
        mtlcd_fbuf_puts(p, "----");
      else {
        os->sprintf(buf, "%d.%u", t/10, util->abs(t)%10 );
        mtlcd_fbuf_puts(p, buf);
      }
      if( (i & 1) )
        mtlcd_fbuf_putchar(p, '\n');
      else
        mtlcd_fbuf_gotox(p, 11);
    }       

    break;

  case 1:
    /* 成功 */
    mtlcd_fbuf_puthz_xy(p, 48, 24+8, HZ_CHENG16);
    mtlcd_fbuf_puthz_xy(p, 64, 24+8, HZ_GONG16);
    break;

  case 2:
    /* 请刷卡 */
    mtlcd_fbuf_puthz_xy(p, 40, 24+8, HZ_QING16);
    mtlcd_fbuf_puthz_xy(p, 56, 24+8, HZ_SHUA16);
    mtlcd_fbuf_puthz_xy(p, 72, 24+8, HZ_KA16);  
    break;

  case 3: {
    /* Starting... */
    char buf[32];
    os->sprintf(buf, "POS:%i", os->version);
    mtlcd_fbuf_puts(p, buf);
    os->sprintf(buf, "\nMain:%i", p->drv.ma_version);
    mtlcd_fbuf_puts(p, buf);
    v = p->drv.s->drv.version;
    os->sprintf(buf, "\nS%04x:%04x", (v>>16)&0xffff, v&0xffff);
    mtlcd_fbuf_puts(p, buf);
    mtlcd_fbuf_puts(p, "\nStarting......");
    break;
  }
  
  default:
    break;
  }
  
  /* 绘制边框 */
  mtlcd_fbuf_rectangle(p, 0, 8, MB_LCD_WIDTH-1, MB_LCD_HEIGHT-1); 
  mtlcd_fbuf_line(p, 0, 23+8, MB_LCD_WIDTH-1, 0);
  for( i = 32; i < MB_LCD_WIDTH; i += 32 ) {
    mtlcd_fbuf_line(p, i, 0+8, 0, 23+8);    
  }

  /* 刷新帧缓存到屏幕 */
  mtlcd_fbuf_show(p);

  /* 释放帧缓存内存(不影响当前屏幕显示内容) */
  mtlcd_fbuf_done(p);

}

/**
 * @brief LCD屏幕驱动获取时间参数
 * @param[in] p 参数控制块
 */
void mtlcd_time_collect(mtlcd_param_t *p) {
  pos_u8_t *arg = p->drv.s->slot->arg.u8;
  p->lcd_time = 100;
  if( arg[0] )
    p->lcd_time = 100 * arg[0];
  p->rfid_time = 2000;
  if( arg[1] )
    p->rfid_time = 100 * arg[1];
  p->erase_time = 10000;  
  if( arg[2] )
    p->erase_time = 100 * arg[2];
  p->keep_time = 10000;
  if( arg[3] )
    p->keep_time = 100 * arg[3];
}

/**
 * @brief LCD屏幕驱动判断按键按下时长
 * @param[in] p 参数控制块
 * @param[in] max_time 最大按键时间
 */
pos_u32_t mtlcd_btn_time_get(mtlcd_param_t *p, pos_u32_t max_time) {
  pos_u32_t ticks, v;
  const pos_lib_t *os;
  os = p->drv.os;

  /* 记录中断时刻 */
  ticks = p->irq_ticks;  
  p->irq_ticks = 0;

  /* 如果当前按钮为弹开则忽略本次中断 */
  if( os->gpio->get(p->pin) != 0 ) {
    return 0;
  }

  /* 如果从未中断则从当前时刻判断时长 */
  if( !ticks )
    ticks = os->tick->get();
  
  /* 如果中断距今已经很久则最多认为LCD亮屏时间 */
  if( os->tick->elaps(ticks) > p->lcd_time )
    ticks = os->tick->get() - p->lcd_time;

  /* 计算超时 */
  max_time = ticks + max_time;
  
  /* 检查直到最大时长超时 */
  while(!os->tick->is_timeout(os->tick->get(), max_time)) {
    /* 按钮松开立即退出 */
    if( os->gpio->get(p->pin) != 0 ) {
      break;
    }
    /* 休眠并直到按钮松开或者超时 */
    os->tick->sleep(20);

    v = os->tick->elaps(ticks);
    /* 如果超过亮屏时长则检查是否告警关闭 */
    if( v >= p->lcd_time )
      mtlcd_alarm_set(p, 0);

    /* 达到扫码时长后启动提示音 */
    if( (p->flags & 2 ) == 0 && v >= p->rfid_time && v < p->rfid_time + 500 ) {
      p->drv.board->beep_set(2700);
      p->flags |= 2;
    /* 扫码提示音超时关闭 */
    } else if( (p->flags & 2) && v >= p->rfid_time + 500 ) {
      p->drv.board->beep_set(0);
      p->flags &= ~2;
    }
    
  }

  /* 关闭扫码提示 */
  if( p->flags & 2 ) {
    p->drv.board->beep_set(0);
    p->flags &= ~2;
  }
  
  /* 返回按钮时长 */
  return os->tick->elaps(ticks);
}


/** 
 * @brief 设置告警状态
 * @param[in] p 参数控制块
 * @param[in] mode 告警状态
 */
void mtlcd_alarm_set(mtlcd_param_t *p, pos_u32_t mode) {
  if( mode == 0 ) {
    /* 忽略: 已经关闭 */
    if( (p->flags & 1) == 0 ) 
      return;
    
    /* 关闭灯光 */
    MB_PIN_LED_SET_R(p->drv.os, 0);
    
    /* 关闭PWM告警 */
    p->drv.board->beep_set(0);

    /* 清除标志 */
    p->flags &= ~1;
  } else {
    /* 忽略: 已经设置 */  
    if( p->flags & 1 )
      return;

    /* 打开灯光 */
    MB_PIN_LED_SET_R(p->drv.os, 1);
    
    /* 打开PWM告警 */
    p->drv.board->beep_set(2700);

    /* 设置标志 */    
    p->flags |= 1;
  }
}

